import { APPLICATION_XML, XmlNodeType } from './xml.js';
function SelectNodesEx(node, xPath) {
    const doc = node.ownerDocument == null ? node : node.ownerDocument;
    const nsResolver = document.createNSResolver(node.ownerDocument == null
        ? node.documentElement
        : node.ownerDocument.documentElement);
    const personIterator = doc.evaluate(xPath, node, nsResolver, XPathResult.ANY_TYPE, null);
    const ns = [];
    let n;
    while ((n = personIterator.iterateNext())) {
        ns.push(n);
    }
    return ns;
}
function SelectNodesNode(node, xPath) {
    const xpath = getNodeDependency('xpath').select;
    return xpath(xPath, node);
}
export const Select = typeof self !== 'undefined' ? SelectNodesEx : SelectNodesNode;
export function Parse(xmlString) {
    xmlString = xmlString.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    let DOMParserCtor;
    if (typeof DOMParser !== 'undefined') {
        DOMParserCtor = DOMParser;
    }
    else {
        DOMParserCtor = getNodeDependency('DOMParser');
    }
    return new DOMParserCtor().parseFromString(xmlString, APPLICATION_XML);
}
export function Stringify(target) {
    let XMLSerializerCtor;
    if (typeof XMLSerializer !== 'undefined') {
        XMLSerializerCtor = XMLSerializer;
    }
    else {
        XMLSerializerCtor = getNodeDependency('XMLSerializer');
    }
    return new XMLSerializerCtor().serializeToString(target);
}
export function SelectSingleNode(node, path) {
    const ns = Select(node, path);
    if (ns && ns.length > 0) {
        return ns[0];
    }
    return null;
}
function _SelectNamespaces(node, selectedNodes = {}) {
    if (isElement(node)) {
        if (node.namespaceURI &&
            node.namespaceURI !== 'http://www.w3.org/XML/1998/namespace' &&
            !selectedNodes[node.prefix || '']) {
            selectedNodes[node.prefix ? node.prefix : ''] = node.namespaceURI;
        }
        for (let i = 0; i < node.childNodes.length; i++) {
            const childNode = node.childNodes.item(i);
            if (childNode && childNode.nodeType === XmlNodeType.Element) {
                _SelectNamespaces(childNode, selectedNodes);
            }
        }
    }
}
export function SelectNamespaces(node) {
    const attrs = {};
    _SelectNamespaces(node, attrs);
    return attrs;
}
export function assign(_target, ...sources) {
    const res = sources.length > 0 ? sources[0] : _target;
    for (let i = 1; i < sources.length; i++) {
        const obj = sources[i];
        for (const prop in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
                continue;
            }
            res[prop] = obj[prop];
        }
    }
    return res;
}
function isNodeType(obj, type) {
    return obj && obj.nodeType === type;
}
export function isElement(obj) {
    return isNodeType(obj, XmlNodeType.Element);
}
export function isDocument(obj) {
    return isNodeType(obj, XmlNodeType.Document);
}
const nodeDependencies = new Map();
export function setNodeDependencies(deps) {
    for (const key in deps) {
        nodeDependencies.set(key, deps[key]);
    }
}
export function getNodeDependency(key) {
    const dep = nodeDependencies.get(key);
    if (!dep) {
        throw new Error(`Node dependency not found: ${key}. Please use 'setNodeDependencies' to register it.`);
    }
    return dep;
}
