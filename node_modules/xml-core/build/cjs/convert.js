"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Convert = void 0;
const error_js_1 = require("./error.js");
class Convert {
    static ToString(buffer, enc = 'utf8') {
        const buf = new Uint8Array(buffer);
        switch (enc.toLowerCase()) {
            case 'utf8':
                return this.ToUtf8String(buf);
            case 'binary':
                return this.ToBinary(buf);
            case 'hex':
                return this.ToHex(buf);
            case 'base64':
                return this.ToBase64(buf);
            case 'base64url':
                return this.ToBase64Url(buf);
            default:
                throw new error_js_1.XmlError(error_js_1.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromString(str, enc = 'utf8') {
        switch (enc.toLowerCase()) {
            case 'utf8':
                return this.FromUtf8String(str);
            case 'binary':
                return this.FromBinary(str);
            case 'hex':
                return this.FromHex(str);
            case 'base64':
                return this.FromBase64(str);
            case 'base64url':
                return this.FromBase64Url(str);
            default:
                throw new error_js_1.XmlError(error_js_1.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static ToBase64(buf) {
        if (typeof btoa !== 'undefined') {
            const binary = this.ToString(buf, 'binary');
            return btoa(binary);
        }
        else if (typeof Buffer !== 'undefined') {
            return Buffer.from(buf).toString('base64');
        }
        else {
            throw new error_js_1.XmlError(error_js_1.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromBase64(base64Text) {
        base64Text = base64Text
            .replace(/\n/g, '')
            .replace(/\r/g, '')
            .replace(/\t/g, '')
            .replace(/\s/g, '');
        if (typeof atob !== 'undefined') {
            return this.FromBinary(atob(base64Text));
        }
        else if (typeof Buffer !== 'undefined') {
            return new Uint8Array(Buffer.from(base64Text, 'base64'));
        }
        else {
            throw new error_js_1.XmlError(error_js_1.XE.CONVERTER_UNSUPPORTED);
        }
    }
    static FromBase64Url(base64url) {
        return this.FromBase64(this.Base64Padding(base64url.replace(/-/g, '+').replace(/_/g, '/')));
    }
    static ToBase64Url(data) {
        return this.ToBase64(data).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    static FromUtf8String(text) {
        const s = unescape(encodeURIComponent(text));
        const uintArray = new Uint8Array(s.length);
        for (let i = 0; i < s.length; i++) {
            uintArray[i] = s.charCodeAt(i);
        }
        return uintArray;
    }
    static ToUtf8String(buffer) {
        const encodedString = String.fromCharCode.apply(null, buffer);
        const decodedString = decodeURIComponent(escape(encodedString));
        return decodedString;
    }
    static FromBinary(text) {
        const stringLength = text.length;
        const resultView = new Uint8Array(stringLength);
        for (let i = 0; i < stringLength; i++) {
            resultView[i] = text.charCodeAt(i);
        }
        return resultView;
    }
    static ToBinary(buffer) {
        let resultString = '';
        for (let i = 0; i < buffer.length; i++) {
            resultString = resultString + String.fromCharCode(buffer[i]);
        }
        return resultString;
    }
    static ToHex(buffer) {
        const splitter = '';
        const res = [];
        for (let i = 0; i < buffer.length; i++) {
            const char = buffer[i].toString(16);
            res.push(char.length === 1 ? '0' + char : char);
        }
        return res.join(splitter);
    }
    static FromHex(hexString) {
        const res = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < hexString.length; i = i + 2) {
            const c = hexString.slice(i, i + 2);
            res[i / 2] = parseInt(c, 16);
        }
        return res;
    }
    static ToDateTime(dateTime) {
        return new Date(dateTime);
    }
    static FromDateTime(dateTime) {
        const str = dateTime.toISOString();
        return str;
    }
    static Base64Padding(base64) {
        const padCount = 4 - (base64.length % 4);
        if (padCount < 4) {
            for (let i = 0; i < padCount; i++) {
                base64 += '=';
            }
        }
        return base64;
    }
}
exports.Convert = Convert;
