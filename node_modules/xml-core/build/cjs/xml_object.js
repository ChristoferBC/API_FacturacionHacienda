"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlObject = void 0;
const tslib_1 = require("tslib");
const CONST = tslib_1.__importStar(require("./const.js"));
const error_js_1 = require("./error.js");
const utils_js_1 = require("./utils.js");
const DEFAULT_ROOT_NAME = 'xml_root';
class XmlObject {
    static LoadXml(param) {
        const xml = new this();
        xml.LoadXml(param);
        return xml;
    }
    static GetElement(element, name, required = true) {
        const xmlNodeList = element.getElementsByTagName(name);
        if (required && xmlNodeList.length === 0) {
            throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MISSING, name, element.localName);
        }
        return xmlNodeList[0] || null;
    }
    static GetAttribute(element, attrName, defaultValue, required = true) {
        if (element.hasAttribute(attrName)) {
            return element.getAttribute(attrName);
        }
        else {
            if (required) {
                throw new error_js_1.XmlError(error_js_1.XE.ATTRIBUTE_MISSING, attrName, element.localName);
            }
            return defaultValue;
        }
    }
    static GetElementById(node, idValue) {
        if (node == null || idValue == null) {
            return null;
        }
        let xel = null;
        if ((0, utils_js_1.isDocument)(node)) {
            xel = node.getElementById(idValue);
        }
        if (xel == null) {
            xel = (0, utils_js_1.SelectSingleNode)(node, `//*[@*[local-name()='Id']='${idValue}']`);
            if (xel == null) {
                xel = (0, utils_js_1.SelectSingleNode)(node, `//*[@*[local-name()='ID']='${idValue}']`);
                if (xel == null) {
                    xel = (0, utils_js_1.SelectSingleNode)(node, `//*[@*[local-name()='id']='${idValue}']`);
                }
            }
        }
        return xel;
    }
    static CreateDocument(root = DEFAULT_ROOT_NAME, namespaceUri = null, prefix = null) {
        if (prefix && !namespaceUri) {
            throw new error_js_1.XmlError(error_js_1.XE.PARAM_REQUIRED, 'namespaceUri', `Prefix '${prefix}' requires namespaceUri`);
        }
        let namePrefix = '';
        let nsPrefix = '';
        let namespaceUri2 = '';
        if (prefix) {
            namePrefix = prefix + ':';
            nsPrefix = ':' + prefix;
        }
        if (namespaceUri) {
            namespaceUri2 = ` xmlns${nsPrefix}="${namespaceUri}"`;
        }
        const name = `${namePrefix}${root}`;
        const doc = (0, utils_js_1.Parse)(`<${name}${namespaceUri2}></${name}>`);
        return doc;
    }
    static GetChildren(node, localName, nameSpace) {
        node = (0, utils_js_1.isDocument)(node) ? node.documentElement : node;
        const res = [];
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if ((0, utils_js_1.isElement)(child) &&
                child.localName === localName &&
                (child.namespaceURI === nameSpace || !nameSpace)) {
                res.push(child);
            }
        }
        return res;
    }
    static GetFirstChild(node, localName, nameSpace) {
        node = (0, utils_js_1.isDocument)(node) ? node.documentElement : node;
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if ((0, utils_js_1.isElement)(child) &&
                child.localName === localName &&
                (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        return null;
    }
    static GetChild(node, localName, nameSpace, required = true) {
        for (let i = 0; i < node.childNodes.length; i++) {
            const child = node.childNodes[i];
            if ((0, utils_js_1.isElement)(child) &&
                child.localName === localName &&
                (child.namespaceURI === nameSpace || !nameSpace)) {
                return child;
            }
        }
        if (required) {
            throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MISSING, localName, node.localName);
        }
        return null;
    }
    constructor(properties = {}) {
        this.prefix = this.GetStatic().prefix || null;
        this.localName = this.GetStatic().localName;
        this.namespaceURI = this.GetStatic().namespaceURI;
        if (properties) {
            for (const [key, value] of Object.entries(properties)) {
                if (value !== undefined) {
                    this[key] = value;
                }
            }
        }
    }
    get Element() {
        return this.element;
    }
    get Prefix() {
        return this.prefix;
    }
    set Prefix(value) {
        this.prefix = value;
    }
    get LocalName() {
        return this.localName || '';
    }
    get NamespaceURI() {
        return this.namespaceURI || null;
    }
    HasChanged() {
        const self = this.GetStatic();
        if (self.items) {
            for (const key in self.items) {
                if (!Object.prototype.hasOwnProperty.call(self.items, key)) {
                    continue;
                }
                const item = self.items[key];
                const value = this[key];
                if (item.parser && value && value.HasChanged()) {
                    return true;
                }
            }
        }
        return this.element === null;
    }
    GetXml(hard) {
        if (!(hard || this.HasChanged())) {
            return this.element || null;
        }
        const thisAny = this;
        const doc = this.CreateDocument();
        const el = this.CreateElement();
        const self = this.GetStatic();
        const localName = this.localName || '';
        if (self.items) {
            for (const key in self.items) {
                if (!Object.prototype.hasOwnProperty.call(self.items, key)) {
                    continue;
                }
                const parser = thisAny[key];
                const selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONST.CONTENT: {
                        const schema = selfItem;
                        const value = schema.converter ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new error_js_1.XmlError(error_js_1.XE.CONTENT_MISSING, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            el.textContent = value;
                        }
                        break;
                    }
                    case CONST.ATTRIBUTE: {
                        const schema = selfItem;
                        const value = schema.converter ? schema.converter.get(parser) : parser;
                        if (schema.required && (value === null || value === void 0)) {
                            throw new error_js_1.XmlError(error_js_1.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (schema.defaultValue !== parser || schema.required) {
                            if (!schema.namespaceURI) {
                                el.setAttribute(schema.localName || '', value);
                            }
                            else {
                                el.setAttributeNS(schema.namespaceURI, schema.localName || '', value);
                            }
                        }
                        break;
                    }
                    case CONST.ELEMENT: {
                        const schema = selfItem;
                        let node = null;
                        if (schema.parser) {
                            if ((schema.required && !parser) || (schema.minOccurs && !parser.Count)) {
                                const missingElement = parser?.localName || schema.localName;
                                throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MISSING, missingElement, localName);
                            }
                            if (parser) {
                                node = parser.GetXml(parser.element === void 0 && (schema.required || parser.Count));
                            }
                        }
                        else {
                            const value = schema.converter ? schema.converter.get(parser) : parser;
                            if (schema.required && value === void 0) {
                                throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MISSING, schema.localName, localName);
                            }
                            if (parser !== schema.defaultValue || schema.required) {
                                if (!schema.namespaceURI) {
                                    node = doc.createElement(`${schema.prefix ? schema.prefix + ':' : ''}${schema.localName}`);
                                }
                                else {
                                    node = doc.createElementNS(schema.namespaceURI, `${schema.prefix ? schema.prefix + ':' : ''}${schema.localName}`);
                                }
                                if (Array.isArray(value)) {
                                    for (const child of value) {
                                        const val = child instanceof XmlObject ? child.GetXml(true) : child;
                                        if (val !== null && node) {
                                            node.appendChild(val);
                                        }
                                    }
                                }
                                else if (value instanceof XmlObject) {
                                    const xmlElement = value.GetXml(true);
                                    if (xmlElement && node) {
                                        node.appendChild(xmlElement);
                                    }
                                }
                                else {
                                    if (node) {
                                        node.textContent = value;
                                    }
                                }
                            }
                        }
                        if (node) {
                            if (schema.noRoot) {
                                const els = [];
                                for (let i = 0; i < node.childNodes.length; i++) {
                                    const colNode = node.childNodes.item(i);
                                    if ((0, utils_js_1.isElement)(colNode)) {
                                        els.push(colNode);
                                    }
                                }
                                const minOccurs = schema.minOccurs || 0;
                                const maxOccurs = schema.maxOccurs || Infinity;
                                if (els.length < minOccurs || els.length > maxOccurs) {
                                    throw new error_js_1.XmlError(error_js_1.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                                }
                                els.forEach((e) => el.appendChild(e.cloneNode(true)));
                            }
                            else if (node.childNodes.length < (schema.minOccurs || 0) ||
                                node.childNodes.length > (schema.maxOccurs || Infinity)) {
                                throw new error_js_1.XmlError(error_js_1.XE.COLLECTION_LIMIT, parser.localName, self.localName);
                            }
                            else {
                                el.appendChild(node);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnGetXml(el);
        this.element = el;
        return el;
    }
    LoadXml(param) {
        let element;
        const thisAny = this;
        if (typeof param === 'string') {
            const doc = (0, utils_js_1.Parse)(param);
            element = doc.documentElement;
        }
        else {
            element = param;
        }
        if (!element) {
            throw new error_js_1.XmlError(error_js_1.XE.PARAM_REQUIRED, 'element');
        }
        const self = this.GetStatic();
        const localName = this.localName || '';
        if (!(element.localName === localName && element.namespaceURI == this.NamespaceURI)) {
            throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MALFORMED, localName);
        }
        if (self.items) {
            for (const key in self.items) {
                if (!Object.prototype.hasOwnProperty.call(self.items, key)) {
                    continue;
                }
                const selfItem = self.items[key];
                switch (selfItem.type) {
                    case CONST.CONTENT: {
                        const schema = selfItem;
                        if (schema.required && !element.textContent) {
                            throw new error_js_1.XmlError(error_js_1.XE.CONTENT_MISSING, localName);
                        }
                        if (!element.textContent) {
                            thisAny[key] = schema.defaultValue;
                        }
                        else {
                            const value = schema.converter
                                ? schema.converter.set(element.textContent)
                                : element.textContent;
                            thisAny[key] = value;
                        }
                        break;
                    }
                    case CONST.ATTRIBUTE: {
                        const schema = selfItem;
                        let hasAttribute;
                        let getAttribute;
                        if (!schema.localName) {
                            throw new error_js_1.XmlError(error_js_1.XE.PARAM_REQUIRED, 'localName');
                        }
                        if (schema.namespaceURI) {
                            hasAttribute = element.hasAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                            getAttribute = element.getAttributeNS.bind(element, schema.namespaceURI, schema.localName);
                        }
                        else {
                            hasAttribute = element.hasAttribute.bind(element, schema.localName);
                            getAttribute = element.getAttribute.bind(element, schema.localName);
                        }
                        if (schema.required && !hasAttribute()) {
                            throw new error_js_1.XmlError(error_js_1.XE.ATTRIBUTE_MISSING, schema.localName, localName);
                        }
                        if (!hasAttribute()) {
                            thisAny[key] = schema.defaultValue;
                        }
                        else {
                            const attrValue = getAttribute();
                            const value = schema.converter && attrValue ? schema.converter.set(attrValue) : attrValue;
                            thisAny[key] = value;
                        }
                        break;
                    }
                    case CONST.ELEMENT: {
                        const schema = selfItem;
                        if (schema.noRoot) {
                            if (!schema.parser) {
                                throw new error_js_1.XmlError(error_js_1.XE.XML_EXCEPTION, `Schema for '${schema.localName}' with flag noRoot must have 'parser'`);
                            }
                            const col = new schema.parser();
                            if (!(col instanceof xml_collection_js_1.XmlCollection)) {
                                throw new error_js_1.XmlError(error_js_1.XE.XML_EXCEPTION, `Schema for '${schema.localName}' with flag noRoot must have 'parser' like instance of XmlCollection`);
                            }
                            col.OnLoadXml(element);
                            delete col.element;
                            const minOccurs = schema.minOccurs || 0;
                            const maxOccurs = schema.maxOccurs || Infinity;
                            if (col.Count < minOccurs || col.Count > maxOccurs) {
                                throw new error_js_1.XmlError(error_js_1.XE.COLLECTION_LIMIT, schema.parser.localName, localName);
                            }
                            thisAny[key] = col;
                            continue;
                        }
                        let foundElement = null;
                        for (let i = 0; i < element.childNodes.length; i++) {
                            const node = element.childNodes.item(i);
                            if (!(0, utils_js_1.isElement)(node)) {
                                continue;
                            }
                            const el = node;
                            if (el.localName === schema.localName && el.namespaceURI == schema.namespaceURI) {
                                foundElement = el;
                                break;
                            }
                        }
                        if (schema.required && !foundElement) {
                            throw new error_js_1.XmlError(error_js_1.XE.ELEMENT_MISSING, schema.parser ? schema.parser.localName : schema.localName, localName);
                        }
                        if (!schema.parser) {
                            if (!foundElement) {
                                thisAny[key] = schema.defaultValue;
                            }
                            else {
                                const textContent = foundElement.textContent || '';
                                const value = schema.converter ? schema.converter.set(textContent) : textContent;
                                thisAny[key] = value;
                            }
                        }
                        else {
                            if (foundElement) {
                                const value = new schema.parser();
                                value.localName = schema.localName;
                                value.namespaceURI = schema.namespaceURI;
                                thisAny[key] = value;
                                value.LoadXml(foundElement);
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.OnLoadXml(element);
        this.prefix = element.prefix || '';
        this.element = element;
    }
    toString() {
        const xml = this.GetXml();
        return xml ? (0, utils_js_1.Stringify)(xml) : '';
    }
    GetElement(name, required = true) {
        if (!this.element) {
            throw new error_js_1.XmlError(error_js_1.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetElement(this.element, name, required);
    }
    GetChildren(localName, nameSpace) {
        if (!this.element) {
            throw new error_js_1.XmlError(error_js_1.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChildren(this.element, localName, nameSpace || this.NamespaceURI || undefined);
    }
    GetChild(localName, required = true) {
        if (!this.element) {
            throw new error_js_1.XmlError(error_js_1.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetChild(this.element, localName, this.NamespaceURI || undefined, required);
    }
    GetFirstChild(localName, namespace) {
        if (!this.element) {
            throw new error_js_1.XmlError(error_js_1.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetFirstChild(this.element, localName, namespace);
    }
    GetAttribute(name, defaultValue, required = true) {
        if (!this.element) {
            throw new error_js_1.XmlError(error_js_1.XE.NULL_PARAM, this.localName);
        }
        return XmlObject.GetAttribute(this.element, name, defaultValue, required);
    }
    IsEmpty() {
        return this.Element === void 0;
    }
    OnLoadXml(_element) {
    }
    GetStatic() {
        return this.constructor;
    }
    GetPrefix() {
        return this.Prefix ? this.prefix + ':' : '';
    }
    OnGetXml(_element) {
    }
    CreateElement(document, localName, namespaceUri = null, prefix = null) {
        if (!document) {
            const createdDocument = this.CreateDocument();
            if (createdDocument) {
                document = createdDocument;
            }
            else {
                throw new error_js_1.XmlError(error_js_1.XE.XML_EXCEPTION, 'Document not created');
            }
        }
        localName = localName || this.localName;
        namespaceUri = namespaceUri || this.NamespaceURI;
        prefix = prefix || this.prefix;
        const tagName = (prefix ? `${prefix}:` : '') + localName;
        const xn = namespaceUri && document
            ? document.createElementNS(namespaceUri, tagName)
            : document?.createElement(tagName);
        if (document && xn) {
            document.importNode(xn, true);
        }
        return xn;
    }
    CreateDocument() {
        return XmlObject.CreateDocument(this.localName, this.NamespaceURI, this.Prefix);
    }
}
exports.XmlObject = XmlObject;
const xml_collection_js_1 = require("./xml_collection.js");
