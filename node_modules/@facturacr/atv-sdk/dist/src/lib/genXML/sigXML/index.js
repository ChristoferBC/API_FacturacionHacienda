"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const xadesjs_1 = require("xadesjs");
const webcrypto_1 = require("@peculiar/webcrypto");
const genKeysAndCert_1 = require("./genKeysAndCert");
const xmldom_alpha_1 = require("xmldom-alpha");
const xmlSchemaHeaderMap_1 = require("../../../xmlSchemaHeaderMap");
function addSigToXML(xml, signature) {
    xml.documentElement.appendChild(signature.GetXml());
    const oSerializer = new xmldom_alpha_1.XMLSerializer();
    const sXML = oSerializer.serializeToString(xml);
    return sXML.toString();
}
const generateId = (crypto) => {
    return (`${1e7}-${1e3}-${4e3}-${8e3}-${1e11}`).replace(/[018]/g, (str) => (str ^ (crypto.getRandomValues(new Uint8Array(1)))[0] & 15 >> str / 4).toString(16));
};
function getOptions(publicKey, x509, referenceId) {
    return {
        keyValue: publicKey,
        references: [
            {
                id: 'Reference-' + referenceId,
                uri: '',
                hash: 'SHA-256',
                transforms: [
                    // 'c14n',
                    'enveloped'
                ]
            }
        ],
        signerRole: {
            claimed: ['ObligadoTributario']
        },
        policy: {
            hash: 'SHA-1',
            identifier: {
                qualifier: 'OIDAsURI',
                value: `https://cdn.comprobanteselectronicos.go.cr/xml-schemas/v${xmlSchemaHeaderMap_1.ATV_VERSION}/facturaElectronica`
            }
        },
        x509: [x509],
        signingCertificate: x509
    };
}
function getAlgorithm() {
    return {
        name: 'RSASSA-PKCS1-v1_5',
        hash: 'SHA-256',
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: 2048
    };
}
function signXML(xmlStr, p12, p12Password) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!p12 || !p12Password) {
            console.log('p12 options undefined');
            // @ts-expect-error pending-to-fix
            return;
        }
        const crypto = new webcrypto_1.Crypto();
        const referenceId = generateId(crypto);
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        xadesjs_1.Application.setEngine('OpenSSL', crypto);
        const xadesXml = new xadesjs_1.SignedXml();
        const algorithm = getAlgorithm();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        const result = (0, genKeysAndCert_1.genKeysAndCert)(crypto, {
            algorithm,
            keyStr: p12,
            password: p12Password
        });
        const x509 = result.cert.certPem;
        const xml = (0, xadesjs_1.Parse)(xmlStr);
        const key = yield result.privateKey;
        const publicKey = yield result.publicKey;
        const signature = yield xadesXml.Sign(algorithm, key, xml, getOptions(publicKey, x509, referenceId));
        return addSigToXML(xml, signature);
    });
}
exports.default = signXML;
//# sourceMappingURL=index.js.map